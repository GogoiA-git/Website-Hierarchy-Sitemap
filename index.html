<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitemap Hierarchy Generator & Exporter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        .hierarchy-container {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styling for the hierarchy tree */
        .tree ul {
            list-style-type: none;
            padding-left: 1.5rem;
            margin-top: 0.25rem;
            border-left: 1px dashed #e5e7eb; /* Light gray dash for tree line */
        }
        .tree > ul {
            padding-left: 0;
            border-left: none;
        }
        .tree li {
            padding-left: 0.5rem;
            position: relative;
        }
        .tree li .toggle-btn {
            cursor: pointer;
            margin-right: 0.5rem;
            transition: transform 0.2s;
        }
        .tree li.expanded > .content > .toggle-btn {
            transform: rotate(90deg);
        }
    </style>
</head>
<body class="bg-gray-50 p-4 md:p-8 min-h-screen font-sans">

    <div class="max-w-4xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-extrabold text-indigo-700 tracking-tight">Sitemap Hierarchy Tool</h1>
            <p class="text-gray-500">Paste your XML sitemap content below to visualize and export the URL structure.</p>
        </header>

        <!-- Input Area -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <label for="xmlInput" class="block text-lg font-medium text-gray-700 mb-2">Paste XML Sitemap Data</label>
            <textarea id="xmlInput" rows="10" class="w-full border-2 border-gray-300 rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out font-mono text-sm" placeholder="<urlset>...</urlset>"></textarea>
            
            <div class="flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 mt-4">
                <button onclick="parseAndDisplay()" id="parseBtn" class="w-full sm:w-auto flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200">
                    Parse XML & Build Hierarchy
                </button>
                <div class="relative w-full sm:w-auto flex-1">
                    <button onclick="exportSitemapHtml()" id="exportBtn" class="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition duration-200" disabled>
                        Export Hierarchy to HTML
                    </button>
                    <!-- Added warning for Canvas preview limitations -->
                    <p id="exportWarning" class="absolute -bottom-6 w-full text-xs text-red-500 text-center sm:text-left hidden">
                        (Download often blocked in this preview environment.)
                    </p>
                </div>
            </div>
        </div>

        <!-- Status and Output Area -->
        <div id="statusMessage" class="hidden p-3 mb-4 rounded-lg text-sm font-medium" role="alert"></div>

        <div class="bg-white p-6 rounded-xl shadow-lg" id="outputCard">
            <h2 class="text-2xl font-semibold text-gray-700 mb-4">Site Structure Hierarchy</h2>
            <div id="hierarchyOutput" class="min-h-[100px] hierarchy-container p-4 border border-gray-200 rounded-lg bg-gray-50 overflow-auto tree">
                <p class="text-gray-400">Hierarchy will appear here after parsing.</p>
            </div>
        </div>
    </div>

    <script>
        // Global variables for Firebase compatibility, though not used here
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

        // --- Helper Functions ---

        /**
         * Shows a transient status message.
         * @param {string} message - The message content.
         * @param {string} type - 'success' or 'error'.
         */
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.textContent = message;
            statusDiv.className = `p-3 mb-4 rounded-lg text-sm font-medium ${type === 'success' ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'}`;
            statusDiv.classList.remove('hidden');

            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }

        /**
         * Toggles the expand/collapse state of a hierarchy node (used in both main app and exported HTML).
         * @param {HTMLElement} button - The button element that was clicked.
         */
        function toggleNode(button) {
            const li = button.closest('li');
            const childrenUl = li.querySelector(':scope > ul');
            if (childrenUl) {
                if (childrenUl.classList.contains('hidden')) {
                    childrenUl.classList.remove('hidden');
                    li.classList.add('expanded');
                    button.innerHTML = '&#9660;'; // Down triangle (or right triangle rotated 90deg)
                } else {
                    childrenUl.classList.add('hidden');
                    li.classList.remove('expanded');
                    button.innerHTML = '&#9658;'; // Right triangle
                }
            }
        }

        // --- Sitemap Parsing Logic ---

        /**
         * Builds the hierarchical tree structure from an array of URLs.
         * @param {string[]} urls - Array of URL strings.
         * @returns {Object} The root of the hierarchy tree.
         */
        function buildHierarchyTree(urls) {
            const tree = {};

            urls.forEach(url => {
                try {
                    // Extract path, removing 'http(s)://' and keeping hostname for the root
                    const { hostname, pathname } = new URL(url);
                    let current = tree;

                    // 1. Set the hostname as the root node if not present
                    if (!current[hostname]) {
                        current[hostname] = { children: {}, _url: null };
                    }
                    current = current[hostname].children;
                    
                    // 2. Process path segments
                    const segments = pathname.split('/').filter(s => s.length > 0);

                    // If URL is just the root (e.g., https://example.com/), it's handled by hostname setup.
                    if (segments.length === 0) {
                        current = tree[hostname];
                        current._url = url; // Mark root node with its URL
                        return;
                    }
                    
                    for (let i = 0; i < segments.length; i++) {
                        const segment = segments[i];

                        if (!current[segment]) {
                            current[segment] = { children: {}, _url: null };
                        }
                        
                        // Move deeper into the tree
                        current = current[segment].children;
                        
                        // If this is the last segment, mark the parent node's URL
                        if (i === segments.length - 1) {
                            // Find the correct node (which is the parent of the 'children' object)
                            let parentNode = tree[hostname];
                            let tempSegments = pathname.split('/').filter(s => s.length > 0);
                            
                            for(let j = 0; j <= i; j++) {
                                if (j === i) {
                                    parentNode = parentNode.children[tempSegments[j]];
                                } else {
                                    parentNode = parentNode.children[tempSegments[j]];
                                }
                            }
                            parentNode._url = url;
                        }
                    }
                } catch (e) {
                    console.error("Error processing URL:", url, e);
                }
            });
            return tree;
        }

        /**
         * Parses the XML, extracts URLs, and builds the hierarchy tree.
         * @param {string} xmlString - The raw XML content.
         * @returns {Object | null} The hierarchy tree or null on error.
         */
        function parseSitemap(xmlString) {
            try {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlString, "text/xml");

                // Check for parsing errors
                if (xmlDoc.getElementsByTagName("parsererror").length) {
                    throw new Error("Invalid XML format. Please check your sitemap data.");
                }
                
                // Get all <loc> elements
                const locs = xmlDoc.getElementsByTagName('loc');
                const urls = [];
                for (let i = 0; i < locs.length; i++) {
                    const url = locs[i].textContent.trim();
                    if (url) {
                        urls.push(url);
                    }
                }
                
                if (urls.length === 0) {
                    throw new Error("No <loc> URLs found in the sitemap.");
                }

                return buildHierarchyTree(urls);

            } catch (error) {
                console.error("Sitemap Parsing Error:", error);
                showStatus(error.message, 'error');
                return null;
            }
        }

        // --- HTML Rendering Logic ---

        /**
         * Recursively generates the HTML list structure for the hierarchy.
         * @param {Object} node - The current node in the tree (children object).
         * @param {boolean} isExported - Flag to modify output for the exported file.
         * @param {number} depth - Current recursion depth.
         * @returns {string} HTML string for the <ul>.
         */
        function generateHierarchyHtml(node, isExported, depth = 0) {
            const childrenKeys = Object.keys(node).sort();
            if (childrenKeys.length === 0) return '';

            // Use 'ul' for the list container. In the exported file, this is needed to scope the toggle.
            let html = '<ul>';

            childrenKeys.forEach(key => {
                const item = node[key];
                const hasChildren = Object.keys(item.children).length > 0;
                
                // Apply 'expanded' class only if it has children and is the root level (depth 0)
                // Exported file will default to collapsed (no 'expanded' class)
                const liClass = hasChildren ? (depth === 0 && !isExported ? 'expanded' : '') : '';
                
                // Content for the list item (URL segment)
                const content = `
                    <div class="content flex items-start py-1 ${item._url ? 'text-blue-800 hover:text-blue-600 font-medium' : 'text-gray-900'}">
                        ${hasChildren 
                            ? `<span onclick="toggleNode(this)" class="toggle-btn text-indigo-500 transition duration-150 ease-in-out select-none text-xl leading-none pt-0.5 ${depth === 0 && !isExported ? 'rotate-90' : ''}">${depth === 0 && !isExported ? '&#9660;' : '&#9658;'}</span>`
                            : `<span class="inline-block w-4 mr-2"></span>` // Spacer for alignment
                        }
                        
                        ${item._url 
                            ? `<a href="${item._url}" target="_blank" class="truncate flex-1" title="${item._url}">/${key}</a>`
                            : `<span class="truncate flex-1">/${key}</span>`
                        }
                    </div>
                `;

                // Recursively generate HTML for children
                const childrenHtml = generateHierarchyHtml(item.children, isExported, depth + 1);
                
                // Determine if the child UL should be hidden initially (only if it has children and is not root/live view)
                const childrenHiddenClass = hasChildren ? (depth === 0 && !isExported ? '' : 'hidden') : '';

                html += `<li class="relative ${liClass}">
                            ${content}
                            <ul class="${childrenHiddenClass}">
                                ${childrenHtml}
                            </ul>
                        </li>`;
            });

            html += '</ul>';
            return html;
        }

        // --- Main Application Functions ---

        let currentHierarchyTree = null;

        /**
         * Step 1: Reads XML, parses it, and displays the result.
         */
        function parseAndDisplay() {
            const exportBtn = document.getElementById('exportBtn');
            const exportWarning = document.getElementById('exportWarning');

            exportBtn.disabled = true;
            exportWarning.classList.add('hidden');

            document.getElementById('hierarchyOutput').innerHTML = '<p class="text-indigo-500">Parsing...</p>';

            const xmlInput = document.getElementById('xmlInput').value.trim();
            if (!xmlInput) {
                showStatus("Please paste XML sitemap data before parsing.", 'error');
                document.getElementById('hierarchyOutput').innerHTML = '<p class="text-gray-400">Hierarchy will appear here after parsing.</p>';
                return;
            }

            currentHierarchyTree = parseSitemap(xmlInput);

            if (currentHierarchyTree) {
                const hierarchyHtml = generateHierarchyHtml(currentHierarchyTree, false); // false for live view
                document.getElementById('hierarchyOutput').innerHTML = hierarchyHtml;
                exportBtn.disabled = false;
                exportWarning.classList.remove('hidden'); // Show warning when export is enabled
                showStatus("Sitemap parsed successfully. Ready to export.", 'success');
            } else {
                 document.getElementById('hierarchyOutput').innerHTML = '<p class="text-red-500">Error during parsing. See status message for details.</p>';
            }
        }

        /**
         * Step 2: Generates a complete, self-contained HTML file for download.
         */
        function exportSitemapHtml() {
            if (!currentHierarchyTree) {
                showStatus("Please parse the XML data first.", 'error');
                return;
            }

            // 1. Generate the inner hierarchy HTML (collapsed by default)
            const hierarchyHtmlContent = generateHierarchyHtml(currentHierarchyTree, true);

            // 2. Define the JavaScript function needed for the export file
            const exportJs = `
                function toggleNode(button) {
                    const li = button.closest('li');
                    const childrenUl = li.querySelector(':scope > ul');
                    if (childrenUl) {
                        if (childrenUl.classList.contains('hidden')) {
                            childrenUl.classList.remove('hidden');
                            li.classList.add('expanded');
                            button.innerHTML = '&#9660;'; 
                        } else {
                            childrenUl.classList.add('hidden');
                            li.classList.remove('expanded');
                            button.innerHTML = '&#9658;'; 
                        }
                    }
                }
            `;

            // 3. Define the custom CSS needed for the export file
            const exportCss = `
                .hierarchy-container { font-family: 'Inter', sans-serif; }
                .tree ul { list-style-type: none; padding-left: 1.5rem; margin-top: 0.25rem; border-left: 1px dashed #e5e7eb; }
                .tree > ul { padding-left: 0; border-left: none; }
                .tree li { padding-left: 0.5rem; position: relative; }
                .tree li .toggle-btn { cursor: pointer; margin-right: 0.5rem; transition: transform 0.2s; }
                .tree li.expanded > .content > .toggle-btn { transform: rotate(90deg); }
                .bg-indigo-50 { background-color: #f0f4ff; }
                .text-indigo-800 { color: #3730a3; }
                .shadow-2xl { box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); }
                .rounded-xl { border-radius: 0.75rem; }
            `;


            // 4. Construct the full, self-contained exported HTML file content
            const exportedHtml = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitemap Hierarchy Export</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>${exportCss}</style>
    <script>${exportJs}</script>
</head>
<body class="bg-gray-100 p-8 min-h-screen font-sans">
    <div class="max-w-4xl mx-auto bg-white p-8 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-extrabold text-indigo-800 mb-6 border-b pb-2">Website URL Hierarchy</h1>
        <div id="hierarchyContent" class="hierarchy-container tree">
            ${hierarchyHtmlContent}
        </div>
        <p class="mt-8 text-sm text-gray-500">Generated by the Sitemap Hierarchy Tool.</p>
    </div>
</body>
</html>
            `;

            // 5. Download the file
            // NOTE: This feature is often blocked by iframe security policies (like the one used in the Canvas preview).
            // It will work when running the file directly in a browser.
            try {
                const blob = new Blob([exportedHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'sitemap-hierarchy-export.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showStatus("HTML file export command executed. Check your downloads folder (may be blocked in this preview).", 'success');
            } catch (e) {
                console.error("Download failed, likely due to iframe security:", e);
                showStatus("Export failed: Download functionality is blocked by security policies in this preview environment. The code is correct, but you must run it in a separate tab to download the file.", 'error');
            }
        }

        // Initialize with a placeholder or example XML for quick testing
        window.onload = () => {
             const exampleXml = `
                <?xml version="1.0" encoding="UTF-8"?>
                <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
                    <url><loc>https://www.example.com/</loc></url>
                    <url><loc>https://www.example.com/about</loc></url>
                    <url><loc>https://www.example.com/products/laptops</loc></url>
                    <url><loc>https://www.example.com/products/monitors/ultrawide</loc></url>
                    <url><loc>https://www.example.com/products/monitors/gaming</loc></url>
                    <url><loc>https://www.example.com/blog/2023/q4-review</loc></url>
                    <url><loc>https://www.example.com/blog/2024/new-trends</loc></url>
                </urlset>
            `;
            document.getElementById('xmlInput').value = exampleXml;
            parseAndDisplay();
        };

    </script>
</body>
</html>
